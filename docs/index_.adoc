= [Katalon Studio] How a Test Case Groovy script is compiled into an executable class file

== Problem to solve

Here is a sample Test Case script (*.groovy) of Katalon Studio:

[source,groovy]
----
include::../Scripts/Main/TC0_start_login/Script1754480671079.groovy[]
----

I can run this script in Katalon Studio, of course. I am quote used to it.

But I am curious about how this script is compiled into an executable JVM `class` file. I want to know the details of the compilation process.

== How the executable class look like

In short, the following groovy source code presents how the binary `*.class` file that Groovy Compiler generates from the above script.

[source]
----
include::testOutput/TestCaseCompilePhasesDifferTest/report/Main_TC0_start_login-9_FINALIZATION.groovy[]
----

What do I find in this souce code interesting?

1. The resulting groovy source code has a complete `class` definition, which implements `void main()` method and `void runScript()` method.
2. The `main()` method is obviously the entry point of the executable class. The `main()` method calls `runScript()` method.
3. The `runScript()` method contains the original set of Groovy statements.
4. And also in front of the `class` definition, I can find the original set of Groovy statements. These statements are syntactically valid; no problem if these statements are there. But it is obvious that the statements in front of the `class` definistion will never be executed by the `main()` method of the `class`. To me the statements outside the `class` definition look like a forgotten ruin.

Other point of interest is the way how the `makeTestObject()` function is treated. The `makeTestObject()` is originally defined as a function in the Test Case script. The resulting `class` implements `private TestObject makeTestObject()` function. This transformation looks quite understandable to me.

== How to run the demo

Open `Test Cases/junit/com.kazurayam.ks/TestCaseCompilePhasesDifferTestRunner` in Katalon Studio, and run it.

You will see the following output in the `build/tmp/testOutput/` directory:

[source,shell]
----
$ tree .
.
└── TestCaseCompilePhasesDifferTest
    ├── classes
    │   └── Main_TC0_start_login.class
    └── report
        ├── Main_TC0_start_login-1_INITIALIZATION.groovy
        ├── Main_TC0_start_login-2_PARSING.groovy
        ├── Main_TC0_start_login-3_CONVERSION.groovy
        ├── Main_TC0_start_login-4_SEMANTIC_ANALYSIS.groovy
        ├── Main_TC0_start_login-5_CANONICALIZATION.groovy
        ├── Main_TC0_start_login-6_INSTRUCTION_SELECTION.groovy
        ├── Main_TC0_start_login-7_CLASS_GENERATION.groovy
        ├── Main_TC0_start_login-8_OUTPUT.groovy
        ├── Main_TC0_start_login-9_FINALIZATION.groovy
        └── Main_TC0_start_login-CompilePhasesDiff.md
----

You can open the `Main_TC0_start_login-9_FINALIZATION.groovy` file in Katalon Studio, and you will see the rebuilt source code of the executable class.

The `Main_TC0_start_login-CompilePhasesDiff.md` file contains the diff report of the original script and the rebuilt source code. Katalon Studio does not provide "Markdown Viewer". You should use Visual Studio Code or any other Markdown viewer to read the diff report.

== How the demo is designed

How did I get this script? --- I used a Groovy class that I developed externally.

- link:https://github.com/kazurayam/GroovyCompilePhasesDiffer[GoovyCompilePhasesDiffer]

You need to download 2 jar files and place them in the `Drivers` folder.

- link:https://mvnrepository.com/artifact/io.github.java-diff-utils/java-diff-utils/4.16[java-diff-utils]

- link:https://github.com/kazurayam/GroovyCompilePhasesDiffer/releases/tag/untagged-08d7fdce06c7a67b200e[groovy-compile-phases-differ]

